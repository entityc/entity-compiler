/*
 * Copyright (c) 2019-2022 The EntityC Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.md file in the project root.
 */

package org.entityc.compiler.generator;

import org.entityc.compiler.EntityCompiler;
import org.entityc.compiler.structure.code.CSAnnotation;
import org.entityc.compiler.structure.code.CSAssignment;
import org.entityc.compiler.structure.code.CSBaseVisitor;
import org.entityc.compiler.structure.code.CSCase;
import org.entityc.compiler.structure.code.CSClass;
import org.entityc.compiler.structure.code.CSComment;
import org.entityc.compiler.structure.code.CSEnum;
import org.entityc.compiler.structure.code.CSEnumItem;
import org.entityc.compiler.structure.code.CSExpression;
import org.entityc.compiler.structure.code.CSFunction;
import org.entityc.compiler.structure.code.CSFunctionPrototype;
import org.entityc.compiler.structure.code.CSHeaderFile;
import org.entityc.compiler.structure.code.CSIfElse;
import org.entityc.compiler.structure.code.CSImport;
import org.entityc.compiler.structure.code.CSMap;
import org.entityc.compiler.structure.code.CSMemberAccess;
import org.entityc.compiler.structure.code.CSMemberScope;
import org.entityc.compiler.structure.code.CSMethod;
import org.entityc.compiler.structure.code.CSMethodArgument;
import org.entityc.compiler.structure.code.CSMethodInvocation;
import org.entityc.compiler.structure.code.CSMethodPrototype;
import org.entityc.compiler.structure.code.CSReturnStatement;
import org.entityc.compiler.structure.code.CSSourceFile;
import org.entityc.compiler.structure.code.CSStatement;
import org.entityc.compiler.structure.code.CSStringConstant;
import org.entityc.compiler.structure.code.CSSwitch;
import org.entityc.compiler.structure.code.CSTop;
import org.entityc.compiler.structure.code.CSType;
import org.entityc.compiler.structure.code.CSVariable;
import org.entityc.compiler.structure.code.CSVariableDeclaration;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class CSVJavaGenerator extends CSBaseVisitor {

    final String INDENT = "    ";
    private final String  fullDirPath;
    PrintStream output = null;
    private       boolean printedClassMemberVariableComment;
    private       boolean printedClassMemberMethodComment;

    public CSVJavaGenerator(String fullDirPath) {
        this.fullDirPath = fullDirPath;
    }

    @Override
    public void visitTop(CSTop top) {
        top.accept(this);
    }

    @Override
    public void visitSourceFile(CSSourceFile sourceFile) {

        String  outputDirectoryPath    = fullDirPath;
        boolean hasOutputDirectoryPath = outputDirectoryPath != null && outputDirectoryPath.length() > 0;

        if (!hasOutputDirectoryPath) {
            return;
        }

        if (!EntityCompiler.ensureDirectory(outputDirectoryPath)) {
            return;
        }

        String fullSourceFilepath = outputDirectoryPath + File.separator;
        if (sourceFile.getNamespace() != null) {
            fullSourceFilepath += String.join(File.separator, sourceFile.getNamespace().getSegments());
            EntityCompiler.ensureDirectory(fullSourceFilepath);
            fullSourceFilepath += File.separator;
        }
        fullSourceFilepath += sourceFile.getFilename();

        try {
            FileOutputStream fos = new FileOutputStream(fullSourceFilepath);
            output = new PrintStream(fos);

            if (sourceFile.getNamespace() != null) {
                output.println("package " + String.join(".", sourceFile.getNamespace().getSegments()) + ";");
            }
            output.println("//");
            output.println("// source file: " + sourceFile.getFilename());
            output.println("//");
            output.println("// THIS SOURCE FILE IS GENERATED by Entity Compiler v" + EntityCompiler.COMPILER_VERSION);
            output.println("// --- DO NOT EDIT ---");
            output.println("// " + new Date());
            output.println("//");
            output.println();
            if (sourceFile.hasImports()) {
                for (CSImport importStmt : sourceFile.getImports()) {
                    output.println("import " + importStmt.getArgument() + ";");
                }
                output.println();
            }
            sourceFile.accept(this);
            output.println();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void visitHeaderFile(CSHeaderFile headerFile) {

    }

    @Override
    public void visitEnum(CSEnum sourceEnum) {
        if (sourceEnum.getComment() != null) {
            printComment(output, "", sourceEnum.getComment());
        }
        output.println("public enum " + sourceEnum.getName() + " {");
        Iterator<CSEnumItem> it = sourceEnum.getItems().iterator();
        while (it.hasNext()) {
            CSEnumItem item = it.next();
            if (item.getComment() != null) {
                printComment(output, INDENT, item.getComment());
            }
            output.print(INDENT + item.getName());
            if (it.hasNext()) {
                output.println(",");
            } else {
                output.println();
            }
        }
        output.println("}");
    }

    private void printComment(PrintStream output, String indent, CSComment comment) {
        if (comment.getStyle() == CSComment.CSCommentStyle.BLOCK) {
            output.println(indent + "/**");
            output.println(indent + " * " + comment.getText());
            output.println(indent + " */");
        } else if (comment.getStyle() == CSComment.CSCommentStyle.LINE) {
            output.println(indent + "// " + comment.getText());
        }
    }

    @Override
    public void visitClass(CSClass sourceClass) {
        printedClassMemberVariableComment = false;
        printedClassMemberMethodComment = false;
        if (sourceClass.getComment() != null) {
            printComment(output, "", sourceClass.getComment());
        }
        printAnnotations(output, "", sourceClass.getAnnotations(), true);
        String keyword = sourceClass.getType() == CSClass.ClassType.Interface ? "interface" : "class";

        output.print("public " + keyword + " " + sourceClass.getName());
        if (sourceClass.getExtendsClass() != null) {
            output.print(" extends " + sourceClass.getExtendsClass().getName());
        }
        if (sourceClass.getImplementsClasses().size() > 0) {
            output.print(" implements ");
            printClassNames(sourceClass.getImplementsClasses());
        }
        output.println();
        output.println("{");
        sourceClass.accept(this);
        output.println("}");
    }

    @Override
    public void visitVariableDeclaration(CSVariableDeclaration declaration) {
        String  indent     = INDENT;
        boolean isInMethod = declaration.getParentNode() != null && declaration.getParentNode() instanceof CSMethod;
        boolean isInClass  = declaration.getParentNode() != null && declaration.getParentNode() instanceof CSClass;
        if (isInMethod) {
            indent += INDENT;
        }
        if (isInClass) {
            if (!printedClassMemberVariableComment) {
                printComment(output, indent, new CSComment(CSComment.CSCommentStyle.BLOCK, "MEMBER VARIABLES"));
                printedClassMemberVariableComment = true;
            } else {
                output.println();
            }
        }
        if (declaration.getComment() != null) {
            printComment(output, indent, declaration.getComment());
        }
        printAnnotations(output, indent, declaration.getAnnotations(), true);
        output.print(indent);
        if (isInClass) {
            output.print(memberAccessAsString(declaration.getMemberAccess()) + " ");
            if (declaration.getMemberScope() == CSMemberScope.CLASS) {
                output.print("static ");
            }
        }
        output.print(typeAsString(declaration.getVariable().getType()) + " " + declaration.getVariable().getName());

        if (declaration.getAssignmentStatement() != null) {
            if (declaration.getAssignmentStatement() instanceof CSMethodInvocation) {
                output.print(" = ");
                visitMethodInvocation((CSMethodInvocation) declaration.getAssignmentStatement());
//                output.println(";");
            } else {
                output.print(" = " + declaration.getAssignmentStatement().toString());
                output.println();
            }
        } else {
            output.println(";");
        }
    }

    @Override
    public void visitMethodArgument(CSMethodArgument methodArgument) {
        printAnnotations(output, "", methodArgument.getAnnotations(), false);
        output.print(typeAsString(methodArgument.getArgumentVariable().getType()) + " " + methodArgument.getArgumentVariable().getName());
    }

    @Override
    public void visitMethod(CSMethod method) {
        output.println();
        if (!printedClassMemberMethodComment) {
            printComment(output, INDENT, new CSComment(CSComment.CSCommentStyle.BLOCK, "METHODS"));
            printedClassMemberMethodComment = true;
        }
        if (method.getComment() != null) {
            printComment(output, INDENT, method.getComment());
        }
        printAnnotations(output, INDENT, method.getAnnotations(), true);
        String memberAccessStr = memberAccessAsString(method.getMemberAccess());
        output.print(INDENT);
        if (memberAccessStr.length() > 0) {
            output.print(memberAccessStr + " ");
        }
        if (method.getMemberScope() == CSMemberScope.CLASS) {
            output.print("static ");
        }

        output.print(typeAsString(method.getReturnType()) + " " + method.getName() + "(");
        printMethodArguments(method.getArguments());
        output.print(")");
        if (method.hasThrowClasses()) {
            output.print(" throws ");
            printClassNames(method.getThrowClasses());
        }
        output.println();
        output.println(INDENT + "{");
        method.accept(this);
        output.println(INDENT + "}");
    }

    @Override
    public void visitMethodPrototype(CSMethodPrototype methodPrototype) {
        output.println();
        if (!printedClassMemberMethodComment) {
            printComment(output, INDENT, new CSComment(CSComment.CSCommentStyle.BLOCK, "METHODS"));
            printedClassMemberMethodComment = true;
        }
        if (methodPrototype.getComment() != null) {
            printComment(output, INDENT, methodPrototype.getComment());
        }
        CSMethod method = methodPrototype.getMethod();
        printAnnotations(output, INDENT, methodPrototype.getAnnotations(), true);
        output.print(INDENT);
        String memberAccessStr = memberAccessAsString(method.getMemberAccess());
        if (memberAccessStr.length() > 0) {
            output.print(memberAccessStr + " ");
        }
        output.print(typeAsString(method.getReturnType()) + " " + method.getName() + "(");
        printMethodArguments(method.getArguments());
        output.print(")");
        if (method.hasThrowClasses()) {
            output.print(" throws ");
            printClassNames(method.getThrowClasses());
        }
        output.println(";");
    }

    private void printMethodArguments(List<CSMethodArgument> arguments) {
        Iterator<CSMethodArgument> ait = arguments.iterator();
        while (ait.hasNext()) {
            CSMethodArgument argument = ait.next();
            visitMethodArgument(argument);
            if (ait.hasNext()) {
                output.print(", ");
            }
        }
    }

    private void printClassNames(List<CSClass> classArgs) {
        Iterator<CSClass> ait = classArgs.iterator();
        while (ait.hasNext()) {
            CSClass argument = ait.next();
            output.print(argument.getName());
            if (ait.hasNext()) {
                output.print(", ");
            }
        }
    }

    @Override
    public void visitReturnStatement(CSReturnStatement s) {
        output.println();
        output.print(INDENT + INDENT + "return ");
        if (s.getStatement() != null) {
            if (s.getStatement() instanceof CSExpression) {
                visitExpression((CSExpression) s.getStatement());
            } else {
                visitStatement(s.getStatement());
            }
            output.println(";");
        } else if (s.getMethodInvocation() != null) {
            visitMethodInvocation(s.getMethodInvocation());
        }
    }

    @Override
    public void visitExpression(CSExpression expression) {
        output.print(expression.toString());
    }

    @Override
    public void visitStatement(CSStatement statement) {
        output.println(INDENT + INDENT + statement.toString());
    }

    @Override
    public void visitMethodInvocation(CSMethodInvocation methodInvocation) {
        if (methodInvocation.getVariable() == null && methodInvocation.getClassName() == null) {
            System.err.println("ERROR: invoking a method requires an object.");
            return;
        }
        if (methodInvocation.getMethodName() == null) {
            System.err.println("ERROR: invoking a method on an object requires a method name.");
            return;
        }

        if (methodInvocation.getParentNode() instanceof CSMethod) {
            output.print(INDENT + INDENT);
        }
        String classOrVariableName = methodInvocation.getClassName() == null ? methodInvocation.getVariable().getName() : methodInvocation.getClassName();
        output.print(classOrVariableName + "." + methodInvocation.getMethodName() + "(");
        if (methodInvocation.hasArguments()) {
            ArrayList<String> argNames = new ArrayList<>();
            for (CSMethodArgument arg : methodInvocation.getArguments()) {
                argNames.add(arg.getArgumentVariable().toString());
            }
            output.print(String.join(", ", argNames));
        }
        output.println(");");
    }

    @Override
    public void visitAssignment(CSAssignment assignment) {
        output.print(INDENT + INDENT);

        CSVariable left = assignment.getLeftHandVariable();
        output.print(fullVariableName(left) + " = ");
        if (assignment.getRightHandStatement() instanceof CSMethodInvocation) {
            visitMethodInvocation((CSMethodInvocation) assignment.getRightHandStatement());
        } else {
            output.print(assignment.getRightHandStatement().toString());
        }
        output.println(";");
    }

    private String fullVariableName(CSVariable variable) {
        StringBuilder builder           = new StringBuilder();
        CSVariable    topParentVariable = variable.getTopParentVariable();
        if (topParentVariable.isMember()) {
            builder.append("this.");
        }
        CSVariable var = topParentVariable;
        do {
            builder.append(var.getName());
            var = var.getSubVariable();
            if (var != null) {
                builder.append(".");
            }
        } while (var != null);
        return builder.toString();
    }

    @Override
    public void visitMap(CSMap map) {

    }

    private String typeAsString(CSType type) {
        if (type == null) {
            return "void";
        }

        String prefix = "";
        String suffix = "";

        switch (type.getCollectionType()) {
            case NONE:
                break;
            case SET:
                prefix = "Set<";
                suffix = ">";
                break;
            case LIST:
                prefix = "List<";
                suffix = ">";
                break;
        }
        return prefix + baseTypeAsString(type) + suffix;
    }

    private String baseTypeAsString(CSType type) {
        if (type == null) {
            return "void";
        }
        if (type.isNativeType()) {
            switch (type.getNativeType()) {
                case INT32:
                    return type.isReference() ? "Integer" : "int";
                case INT64:
                    return type.isReference() ? "Long" : "long";
                case FLOAT:
                    return type.isReference() ? "Float" : "float";
                case DOUBLE:
                    return type.isReference() ? "Double" : "double";
                case STRING:
                    return "String";
                case BOOLEAN:
                    return type.isReference() ? "Boolean" : "boolean";
                case DATE:
                    return "Date";
            }
        } else if (type.getClassName() != null) {
            StringBuilder typeName = new StringBuilder();
            typeName.append(type.getClassName());

            if (type.getTemplateArgumentTypes() != null) {
                typeName.append("<");
                for (CSType argType : type.getTemplateArgumentTypes()) {
                    typeName.append(argType.getClassName());
                }
                typeName.append(">");
            }
            return typeName.toString();
        } else if (type.isEnumType()) {
            return type.getEnumName();
        }

        return "void";
    }

    private String memberAccessAsString(CSMemberAccess memberAccess) {
        switch (memberAccess) {
            case PUBLIC:
                return "public";
            case PRIVATE:
                return "private";
            case PROTECTED:
                return "protected";
            case NONE:
                break;
        }
        return "";
    }

    private void printAnnotations(PrintStream output, String indent, Collection<CSAnnotation> annotations, boolean onSeperateLines) {
        StringBuilder stringBuilder = new StringBuilder();
        buildAnnotations(stringBuilder, indent, annotations, onSeperateLines);
        output.print(stringBuilder);
    }

    private void buildAnnotations(StringBuilder stringBuilder, String indent, Collection<CSAnnotation> annotations, boolean onSeperateLines) {
        Iterator<CSAnnotation> it = annotations.iterator();
        while (it.hasNext()) {
            CSAnnotation annotation = it.next();
            if (annotation != null) {
                stringBuilder.append(indent + "@" + annotation.getName());
                if (annotation.hasArgumentArray()) {
                    // array type
                    ArrayList<String> args = new ArrayList<>();
                    for (Object argObj : annotation.getArgumentArray()) {
                        if (argObj instanceof String) {
                            args.add("\"" + argObj + "\"");
                        } else if (argObj instanceof String[]) {
                            String   arg     = "{";
                            String[] subArgs = (String[]) argObj;
                            for (int i = 0; i < subArgs.length; i++) {
                                String str = subArgs[i];
                                arg += "\"" + str + "\"";
                                if (i < (subArgs.length - 1)) {
                                    arg += ",";
                                }
                            }
                            arg += "}";
                            args.add(arg);
                        } else if (argObj instanceof CSVariable) {
                            args.add(((CSVariable) argObj).getName());
                        } else {
                            args.add(argObj.toString());
                        }
                    }
                    stringBuilder.append("(" + String.join(", ", args) + ")");
                } else if (annotation.hasArgumentMap()) {
                    // map type
                    Map<String, Object> argumentMap = annotation.getArgumentMap();
                    ArrayList<String>   mapStrings  = new ArrayList<>();
                    for (String key : argumentMap.keySet()) {
                        Object argObj = argumentMap.get(key);
                        if (argObj instanceof String) {
                            mapStrings.add(key + " = \"" + argObj + "\"");
                        } else if (argObj instanceof String[]) {
                            mapStrings.add("{");
                            for (String str : (String[]) argObj) {
                                mapStrings.add("\"" + str + "\"");
                            }
                            mapStrings.add("}");
                        } else if (argObj instanceof CSVariable) {
                            mapStrings.add(key + " = " + ((CSVariable) argObj).getName());
                        } else if (argObj instanceof CSAnnotation) {
                            ArrayList<CSAnnotation> oneAnnotation = new ArrayList<CSAnnotation>();
                            oneAnnotation.add((CSAnnotation) argObj);
                            StringBuilder miniBuilder = new StringBuilder();
                            buildAnnotations(miniBuilder, "", oneAnnotation, false);
                            mapStrings.add(key + " = " + miniBuilder);
                        } else {
                            mapStrings.add(key + " = " + argObj.toString());
                        }
                    }
                    stringBuilder.append("(" + String.join(", ", mapStrings) + ")");
                }
                if (onSeperateLines) {
                    stringBuilder.append("\n");
                } else {
                    stringBuilder.append(" ");
                }
            }
        }
    }

    @Override
    public void visitBetween(Class after, Class before) {
        if (after.equals(CSVariableDeclaration.class) && before.equals(CSStatement.class)) {
            output.println();
        }
    }

    @Override
    public void visitFunction(CSFunction function) {

    }

    @Override
    public void visitFunctionPrototype(CSFunctionPrototype functionPrototype) {

    }

    @Override
    public void visitSwitch(CSSwitch csSwitch) {

    }

    @Override
    public void visitCase(CSCase csCase) {

    }

    @Override
    public void visitStringConstant(CSStringConstant stringConstant) {

    }

    @Override
    public void visitIfElse(CSIfElse ifElse) {

    }
}
