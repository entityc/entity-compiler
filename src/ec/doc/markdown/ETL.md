$[let doNotEditMessage = "DO NOT EDIT THIS DOCUMENT, IT WAS GENERATED BY FILE: " + __template.name]
$[let alarm = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"]
[//]: # (${alarm})
[//]: # (${doNotEditMessage})
[//]: # (${alarm})

# Entity Transform Language

## Overview

Templates, written in the Entity Transform Language, are used to transform your entity and domain definitions into code or other renderings. A template typically looks very much like what it is going to generate except that it has special tags to insert variables, repeat blocks of your template, conditionally include blocks of your template, and many other powerful features for constructing code.

### Example

It's always best to start with a simple example.  Say this is our **template**:

	All the entities:
	${$}[foreach entity in model.entities]
	>> ${$}{entity.name} <<
	${$}[/foreach]

If your model has entities named "Person" and "Company", then your **output** would be:

	All the entities:
	>> Person <<
	>> Company <<

The above template used the template instruction `foreach` to iterate through all the entities of the provided model. The portions of the template not inside those special instructions went straight to the output.

## Language

Templates use a simple programming language to help you construct the output that you require. If your template does not contain any of this program code in it, the template text would all simply go to the output, making the output the same as your template. However, the power of the template is in its programming language.

The compiler has to have some way of differentiating just plain text that you want to go to the output and the template program code. It does this using what are called tags. Tags contain the template program code. 

There are two types of tags, one that contains program code that controls the flow of the template program and another for expressions that instruct data to be inserted into the output.

### Expression Tags

Expression tags instruct the compiler to insert data into the output. Expression tags start with a `${$}{` and end with a `}`.

For example: `${$}{entity.name}` would dereference the `entity` object to extract its `name` field then send that to the output.

Before a template begins to execute,  the following variables are set and are immediately accessible by your template:

|Variable | Type | Description|
| -------	| ----	| ----------	|
|`model`|`Model`| This is an object that represents the entire data model of entities, domains, and interfaces.|
|`template`|`Template`|Contains information about the template itself such as its version and target language.|
|`compiler`|`Compiler`|Contains information about the compiler.|
|`configuration`|`Configuration`|The configuration object contains configuration settings used for this execution of the compiler.|
|`space`|`Space`|The application space defined in the model.|

In your template you can create variables an instruction such as `let` or `capture`. Variables do **not** need to be declared before assignment and automatically assume the type of what is being assigned to it.

### Instruction Tags

Instructions allow you to perform operations to do things such as make assignments to variables, change the program flow, perform file operations, etc. Instructions start with `${$}[` and end with `]`:

`${$}[`*instruction*`]`

For some instructions, this is all that is required, but others need to define a block of the template, inside which can be other instructions or just text. For these instructions, there is an end-instruction tag as follows (notice the `/`):

`${$}[/`*instruction*`]` 

For instance, you can use the `log` instruction as follows to surround template text/code to go to standard output for debug purposes:

	${$}[log debug]
	At this point the entity name is: ${$}{entity.name}
	${$}[/log]

The rest of this section will briefly go through all the supported instructions. As instructions are described below, they will indicate whether or not they require an end-instruction tag in their usage.

For a full list of instructions see: [Template Instructions](ETL_Instructions.md)

### Expressions

Expressions are a powerful way to manipulate data or create complex conditions. The available operators and precedence is similar to many procedural languages.

|Operation | Operator | Usage | Description|
| --------	| --------	| -----	| ----------	|
|Dereference|`.`|*expression*`.`*field*|Accesses a field of an object represented by the expression. If the expression does not resolve to an object, an error will occur.|
|Filter|<code>\|</code>|*expression*<code>\|</code>*filter*|Applies a filter to the object represented by the expression. Filters are described in detail in a below section.|
|Logical NOT|`!`|`!`*expression*|Performs a logical not of the expression. This means the output of this operation is a boolean value. The input expression can either be boolean, a number (where a non-zero number is interpreted as `true`) or an object (where a non-null object is interpreted as `true`.|
|Multiply|`*`|*expression*`*`*expression*|Multiplies the two expressions. Both expressions must evaluate to a number.|
|Divide|`/`|*expression*`/`*expression*|Divides the first expression by the second. Both expressions must evaluate to a number.|
|Modulo|`%`|*expression*`%`*expression*|Performs the modulo of the first expression with the second. Both expressions must evaluate to a number.|
|Add|`+`|*expression*`+`*expression*|Adds the two expressions. Both expressions must evaluate to a number.|
|Subtract|`-`|*expression*`-`*expression*|Subtracts the second expression from the first. Both expressions must evaluate to a number.|
|Less than or equal|`<=`|*expression*`<=`*expression*|Evaluates to `true` if the first expression is numerically **less than or equal to** the second expression.|
|Less than|`<`|*expression*`<`*expression*|Evaluates to `true` if the first expression is numerically **less than** the second expression.|
|Greater than or equal|`>=`|*expression*`>=`*expression*|Evaluates to `true` if the first expression is numerically **greater than or equal to** the second expression.|
|Greater than|`>`|*expression*`>`*expression*|Evaluates to `true` if the first expression is numerically **greater than** the second expression.|
|Logical AND|`&&`|*expression*`&&`*expression*|Evaluates to `true` if **both** expressions evaluate to `true`.|
|Logical OR|<code>\|\|</code>|*expression*<code>\|\|</code>*expression*|Evaluates to `true` if **either** expression evaluates to `true`.|
|Select|`?:`|*expression*`?`*expression*`:`*expression*| If the first expression evaluates to `true` then the second expression is selected, otherwise the third expression is selected. The entire expression evaluates to the selected expression. |

The operator are listed in order of precedence. So for an expression such as `a + b * c`, the `*` will execute first, then the `+`. However, you can always use `(` and `)` to force an order. So for `(a + b) * c`, the `+` is executed first since it is inside the parenthesis.

#### Filters (the <code>\|</code> operator)

Filters offer a powerful and compact way to transform an object or value in some way. The syntax of the expression is as follows.

*expression*`|`*filter*\[`:`*parameter*]` `\[*argument*` `...]

So the `|` character is used to denote the application of a filter that can have an optional parameter as well as multiple arguments separated by spaces.

For example, lets say we want to capitalize an attribute name, we would define our variable tag as follows:

	${$}{attribute.name | capitalize}

The `capitalize` filter is one of the built in filters (see below).

One of the most common filters is the `domain` filter. This filter allows you to convert a model element (such as an entity or attribute) into a domain-specific version of that element. This is discussed in more detail in the **Domain** part of this document.

Filters can also have arguments to allow a filter to have alternate behaviors.

Here is the full list of filters:

| Filter Name | Description |
|---|---|
$[let manager = __documentationManager]
$[foreach filter in manager.filters()]
| [`${filter.name}`](#filter_detail_${filter.name}) | ${filter.description} |
$[/foreach]

For the filters that have a parameter or options, they are given a subsection below to describe them.

$[foreach filter in manager.filters()]
<hr/>

<a name="filter_detail_${filter.name}">
##### Filter: `${filter.name}`
</a>

${filter.description}

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
$[foreach validInput in filter.singleInputTypes]
$[let description = validInput.hasDescription ? validInput.description : manager.modelClassMeta(validInput.name).description]
| `${validInput.name}` | ${description} |
$[/foreach]
$[foreach validInput in filter.collectionInputTypes]
$[let description = validInput.hasDescription ? validInput.description : manager.modelClassMeta(validInput.name).description]
| `Collection<${validInput.name}>` | ${description} |
$[/foreach]

$[if filter.hasValidParameter]
This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
$[foreach param in filter.validParameters]
| `${filter.name}:`*${param.name}* | ${param.description} |
$[/foreach]

$[/if]
$[if filter.hasValidOption]

Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
$[foreach option in filter.validOptions]
| `${option.name}` | ${option.description} |
$[/foreach]

$[/if]
$[/foreach]

## Model Classes

Your application model contains all entities, attributes, relationships, domains, etc. that you have defined. Each type of element in your model has its own class and are placed into a tree structure after parsing your source files.

These classes are explained in detail in their own document: [Entity Model Classes](EMC.md). 