[//]: # (!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)
[//]: # (DO NOT EDIT THIS DOCUMENT, IT WAS GENERATED BY FILE: ETL.md)
[//]: # (!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)

# Entity Transform Language

## Overview

Templates, written in the Entity Transform Language, are used to transform your entity and domain definitions into code or other renderings. A template typically looks very much like what it is going to generate except that it has special tags to insert variables, repeat blocks of your template, conditionally include blocks of your template, and many other powerful features for constructing code.

### Example

It's always best to start with a simple example.  Say this is our **template**:

	All the entities:
	$[foreach entity in model.entities]
	>> ${entity.name} <<
	$[/foreach]

If your model has entities named "Person" and "Company", then your **output** would be:

	All the entities:
	>> Person <<
	>> Company <<

The above template used the template instruction `foreach` to iterate through all the entities of the provided model. The portions of the template not inside those special instructions went straight to the output.

## Language

Templates use a simple programming language to help you construct the output that you require. If your template does not contain any of this program code in it, the template text would all simply go to the output, making the output the same as your template. However, the power of the template is in its programming language.

The compiler has to have some way of differentiating just plain text that you want to go to the output and the template program code. It does this using what are called tags. Tags contain the template program code. 

There are two types of tags, one that contains program code that controls the flow of the template program and another for expressions that instruct data to be inserted into the output.

### Expression Tags

Expression tags instruct the compiler to insert data into the output. Expression tags start with a `${` and end with a `}`.

For example: `${entity.name}` would dereference the `entity` object to extract its `name` field then send that to the output.

Before a template begins to execute,  the following variables are set and are immediately accessible by your template:

|Variable | Type | Description|
| -------	| ----	| ----------	|
|`model`|`Model`| This is an object that represents the entire data model of entities, domains, and interfaces.|
|`template`|`Template`|Contains information about the template itself such as its version and target language.|
|`compiler`|`Compiler`|Contains information about the compiler.|
|`configuration`|`Configuration`|The configuration object contains configuration settings used for this execution of the compiler.|
|`space`|`Space`|The application space defined in the model.|

In your template you can create variables an instruction such as `let` or `capture`. Variables do **not** need to be declared before assignment and automatically assume the type of what is being assigned to it.

### Instruction Tags

Instructions allow you to perform operations to do things such as make assignments to variables, change the program flow, perform file operations, etc. Instructions start with `$[` and end with `]`:

`$[`*instruction*`]`

For some instructions, this is all that is required, but others need to define a block of the template, inside which can be other instructions or just text. For these instructions, there is an end-instruction tag as follows (notice the `/`):

`$[/`*instruction*`]` 

For instance, you can use the `log` instruction as follows to surround template text/code to go to standard output for debug purposes:

	$[log debug]
	At this point the entity name is: ${entity.name}
	$[/log]

For a full list of instructions see: [Template Instructions](ETL_Instructions.md)

### Expressions

Expressions are a powerful way to manipulate data or create complex conditions. The available operators and precedence is similar to many procedural languages.

|Operation | Operator | Usage | Description|
| --------	| --------	| -----	| ----------	|
|Dereference|`.`|*expression*`.`*field*|Accesses a field of an object represented by the expression. If the expression does not resolve to an object, an error will occur.|
|Filter|<code>\|</code>|*expression*<code>\|</code>*filter*|Applies a filter to the object represented by the expression. Filters are described in detail in a below section.|
|Logical NOT|`!`|`!`*expression*|Performs a logical not of the expression. This means the output of this operation is a boolean value. The input expression can either be boolean, a number (where a non-zero number is interpreted as `true`) or an object (where a non-null object is interpreted as `true`.|
|Multiply|`*`|*expression*`*`*expression*|Multiplies the two expressions. Both expressions must evaluate to a number.|
|Divide|`/`|*expression*`/`*expression*|Divides the first expression by the second. Both expressions must evaluate to a number.|
|Modulo|`%`|*expression*`%`*expression*|Performs the modulo of the first expression with the second. Both expressions must evaluate to a number.|
|Add|`+`|*expression*`+`*expression*|Adds the two expressions. Both expressions must evaluate to a number.|
|Subtract|`-`|*expression*`-`*expression*|Subtracts the second expression from the first. Both expressions must evaluate to a number.|
|Less than or equal|`<=`|*expression*`<=`*expression*|Evaluates to `true` if the first expression is numerically **less than or equal to** the second expression.|
|Less than|`<`|*expression*`<`*expression*|Evaluates to `true` if the first expression is numerically **less than** the second expression.|
|Greater than or equal|`>=`|*expression*`>=`*expression*|Evaluates to `true` if the first expression is numerically **greater than or equal to** the second expression.|
|Greater than|`>`|*expression*`>`*expression*|Evaluates to `true` if the first expression is numerically **greater than** the second expression.|
|Logical AND|`&&`|*expression*`&&`*expression*|Evaluates to `true` if **both** expressions evaluate to `true`.|
|Logical OR|<code>\|\|</code>|*expression*<code>\|\|</code>*expression*|Evaluates to `true` if **either** expression evaluates to `true`.|
|Select|`?:`|*expression*`?`*expression*`:`*expression*| If the first expression evaluates to `true` then the second expression is selected, otherwise the third expression is selected. The entire expression evaluates to the selected expression. |

The operator are listed in order of precedence. So for an expression such as `a + b * c`, the `*` will execute first, then the `+`. However, you can always use `(` and `)` to force an order. So for `(a + b) * c`, the `+` is executed first since it is inside the parenthesis.

#### Filters (the <code>\|</code> operator)

Filters offer a powerful and compact way to transform an object or value in some way. The syntax of the expression is as follows.

*expression*`|`*filter*\[`:`*parameter*]` `\[*argument*` `...]

So the `|` character is used to denote the application of a filter that can have an optional parameter as well as multiple arguments separated by spaces.

For example, lets say we want to capitalize an attribute name, we would define our variable tag as follows:

	${attribute.name | capitalize}

The `capitalize` filter is one of the built in filters (see below).

One of the most common filters is the `domain` filter. This filter allows you to convert a model element (such as an entity or attribute) into a domain-specific version of that element. This is discussed in more detail in the **Domain** part of this document.

Filters can also have arguments to allow a filter to have alternate behaviors.

Here is the full list of filters:

| Filter Name | Description |
|---|---|
| [`append`](#filter_detail_append) | Appends two lists together to form a new list. |
| [`capitalize`](#filter_detail_capitalize) | Capitalizes the input string - that is, it forces the first character to be uppercase. |
| [`dashes`](#filter_detail_dashes) | Converts a string using the camel case to represent words to a string that uses the dash character as a separator between words. For instance, the string "EntityCompiler" would convert to "Entity-Compiler". This is often followed with the "lowercase" when used tocreate part of a URL path. |
| [`domain`](#filter_detail_domain) | Allows you to convert a model element (such as an entity or attribute) into a domain-specific version of that element. The domain-specific element can have altered properties such as a different name or different tags. For convenience this filter can also accept domain specific elements in which case it effectively replaces the domain with the specified one. |
| [`fullname`](#filter_detail_fullname) | When the input is an domain-based entity, it will combine the namespace of the domain with the name of the entity in that domain to form a period based full name (e.g., `com.example.model.Widget`). This can be useful for construction a Java import statement, for instance. |
| [`has`](#filter_detail_has) | deprecated |
| [`is`](#filter_detail_is) | Checks to see if the input is a particular kind of thing. For now only `identifier` is supported which checks to make sure it is a string that starts with a letter and contains no special characters or spaces.. |
| [`join`](#filter_detail_join) | Given a multiline string, it joins all lines into one (replacing all carriage returns with a space). Given an array of strings, it joins the strings by inserted the provided delimiter between them. |
| [`json`](#filter_detail_json) | This is used on an entity object that you want to convert into a JSON string. For attribute values it will randomly generate based on their type. This is currently only used when generating Postman configuration files to provide a sample POST body. |
| [`language`](#filter_detail_language) | Using this filter allows the template to remain agnostic to the syntax of the language for which they are generating code. For instance, if you feed in a type object, it will use the language assigned to the template and look up the keyword for the type in that language. For instance, if the type is `string` and the language is `java`, it would output `String`. |
| [`lowercase`](#filter_detail_lowercase) | Forces all characters of the input to be lowercase. |
| [`map`](#filter_detail_map) | This filter is probably the most complicated one but can be very powerful in helping to pattern match an expression at its input with one provided as a parameter. When the expressions match, it not only returns true but also maps operands from the input expression to the parameter expression. |
| [`name`](#filter_detail_name) | This simply calls `getName()` on the input. It is more of a convenient way to get the name by using a filter. |
| [`nameas`](#filter_detail_nameas) | Places underscore between words then forces all characters to be lowercase. |
| [`path`](#filter_detail_path) | This will convert a string or namespace object into a string where by a '/' character is used as a delimiter instead of a '.'. This is useful when you need to convert a namespace into a filepath. |
| [`plural`](#filter_detail_plural) | This will attempt to pluralize the last word of the input string. If it can't determine the pluralization it may just return the same string. |
| [`reverse`](#filter_detail_reverse) | Given a collection of objects, this will return a collection that has the reverse order of the input. |
| [`sort`](#filter_detail_sort) | Given a collection of objects, this will return a collection that is sorted by name. This is useful when generating code that is consistent each time in terms of the order of objects in the output. |
| [`title`](#filter_detail_title) | Given a string of words in camel case format, this will capitalize each word in the string except those words that are typically not capitalized in a title (such as 'of', 'the'. 'and', etc.). |
| [`trim`](#filter_detail_trim) | Removes white space from both ends of the input string. |
| [`type`](#filter_detail_type) | Filters attribute lists optionally by its type (only array/single type supported currently). |
| [`uncapitalize`](#filter_detail_uncapitalize) | Uncapitalizes the input string - that is, it forces the first character to be lowercase. |
| [`uppercase`](#filter_detail_uppercase) | Forces all characters of the input to be uppercase. |
| [`view`](#filter_detail_view) | Given a domain entity and the name of a view, this will return the view object. |
| [`words`](#filter_detail_words) | Given a string of words in camel case format, this will simply break up the words using a space character as a delimiter and does not change upper or lower case. |
| [`wrap`](#filter_detail_wrap) | Given a sentence or paragraph string and an optional line width, this will perform a word wrap of the string to the output. You can optionally provide a line prefix (such as a line comment designator). The column position of the first line is used as the starting column position of each wrapped line of text. |

For the filters that have a parameter or options, they are given a subsection below to describe them.

<hr/>

<a name="filter_detail_append"></a>
##### Filter: `append`

Appends two lists together to form a new list.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `Collection<MTAttribute>` | Represents an attribute of an entity. |
| `Collection<MTDEAttribute>` | Represents an attribute in your model in the context of a domain. |
| `Collection<MTEntity>` | Represents an entity in your model. |
| `Collection<MTDEntity>` | Represents an entity in your model in the context of a domain. |
| `Collection<MTModule>` | Represents a grouping of entities. |
| `Collection<MTEnum>` | Represents an enum in your model. |
| `Collection<MTEnumItem>` | Represents an enum item. |
| `Collection<MTRelationship>` | Represents a relationship of an entity. |
| `Collection<MTDERelationship>` | Represents a relationship in your model in the context of a domain. |
| `Collection<FTTemplate>` | Represents an actual template containing code to execute. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `append:`*otherList* | The list to append to the input of this filter. Both should be valid Collection types. |

<hr/>

<a name="filter_detail_capitalize"></a>
##### Filter: `capitalize`

Capitalizes the input string - that is, it forces the first character to be uppercase.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to capitalize. |

<hr/>

<a name="filter_detail_dashes"></a>
##### Filter: `dashes`

Converts a string using the camel case to represent words to a string that uses the dash character as a separator between words. For instance, the string "EntityCompiler" would convert to "Entity-Compiler". This is often followed with the "lowercase" when used tocreate part of a URL path.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to rename with dashes. |

<hr/>

<a name="filter_detail_domain"></a>
##### Filter: `domain`

Allows you to convert a model element (such as an entity or attribute) into a domain-specific version of that element. The domain-specific element can have altered properties such as a different name or different tags. For convenience this filter can also accept domain specific elements in which case it effectively replaces the domain with the specified one.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTSpace` | The space class represents the top of your entity model and also defines information about where you can import entities along with other elements such as units, domains, templates, etc. that are important for application synthesis. Most templates start with the space object to obtains the list of modules or entities in your model. |
| `MTModule` | Represents a grouping of entities. |
| `MTEntity` | Represents an entity in your model. |
| `MTDEntity` | Represents an entity in your model in the context of a domain. |
| `MTDEnum` | Represents an enum in the context of a domain. |
| `MTDEnumItem` | Represents an enum item in the context of a domain. |
| `MTAttribute` | Represents an attribute of an entity. |
| `MTDEAttribute` | Represents an attribute in your model in the context of a domain. |
| `MTRelationship` | Represents a relationship of an entity. |
| `MTDERelationship` | Represents a relationship in your model in the context of a domain. |
| `MTEnum` | Represents an enum in your model. |
| `MTEnumItem` | Represents an enum item. |
| `MTTypedef` | Represents a type definition useful in dealing with bit fields. |
| `MTConstant` | This represents a constant in a model expression. |
| `Collection<MTAttribute>` | Represents an attribute of an entity. |
| `Collection<MTAttributeConstraint>` | Represents some type of constraint placed upon an attribute. Constraints can help prevent attributes from receiving values that are not valid for a specific application. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `domain:`*domainName* | Specifies a specific domain name or domain object to filter through. If not specified, the currently defined domain is used. |

<hr/>

<a name="filter_detail_fullname"></a>
##### Filter: `fullname`

When the input is an domain-based entity, it will combine the namespace of the domain with the name of the entity in that domain to form a period based full name (e.g., `com.example.model.Widget`). This can be useful for construction a Java import statement, for instance.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTDomainBased` | Any class that is with respect to a domain (such as MTDEntity). |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `fullname:`*delimiter* | Specifies a delimiter to use instead of a period. |

<hr/>

<a name="filter_detail_has"></a>
##### Filter: `has`

deprecated

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTDEntity` | Represents an entity in your model in the context of a domain. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `view` | If specified, the filter checks if the domain entity has the specified view by name. |
| `attribute` | If specified, the filter checks if the domain entity has the specified attribute by name. |

<hr/>

<a name="filter_detail_is"></a>
##### Filter: `is`

Checks to see if the input is a particular kind of thing. For now only `identifier` is supported which checks to make sure it is a string that starts with a letter and contains no special characters or spaces..

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` |  |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `is:`*thingOfThing* | The kind of thing you want to check for such as identifier. |

<hr/>

<a name="filter_detail_join"></a>
##### Filter: `join`

Given a multiline string, it joins all lines into one (replacing all carriage returns with a space). Given an array of strings, it joins the strings by inserted the provided delimiter between them.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The base string to start joining onto. |
| `MFArray` | The array of strings to join. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `delim` | The delimiter to place between the joined strings. (default: a space) |

<hr/>

<a name="filter_detail_json"></a>
##### Filter: `json`

This is used on an entity object that you want to convert into a JSON string. For attribute values it will randomly generate based on their type. This is currently only used when generating Postman configuration files to provide a sample POST body.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTDEntity` | Represents an entity in your model in the context of a domain. |
| `Collection<MTDEAttribute>` | Represents an attribute in your model in the context of a domain. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `escaped` | If specified, any double quotes will be converted to escaped double quotes.  |

<hr/>

<a name="filter_detail_language"></a>
##### Filter: `language`

Using this filter allows the template to remain agnostic to the syntax of the language for which they are generating code. For instance, if you feed in a type object, it will use the language assigned to the template and look up the keyword for the type in that language. For instance, if the type is `string` and the language is `java`, it would output `String`.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTType` | Represents a data type of an attribute. Such types can be as simple as a primitive (native) type (like `int32`) and as complex as a secondary entity. |
| `MTNativeType` | Represents a native data type such as `int32`, `float`, `string`, etc. Basically anything except a secondary entity type. |
| `MTEnum` | Represents an enum in your model. |
| `MTTypedef` | Represents a type definition useful in dealing with bit fields. |
| `MTDEAttributeConstraintExpression` | Represents a constraint on an attribute in the form of an expression. |
| `MTExpression` | An expression is a tree of operations, constants, methods and operands that evaluate to something at runtime. An example of an expression is like a constraint placed on an attribute. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `hasNullable` | Use this option to find out if the input type has a nullable version in the template's language. |
| `nullable` | Some language have both native and object versions of their types. For instance Java has `int` and `Integer`. The biggest difference is that `Integer` is an object and thus can be null whereas `int` cannot be null. Using this option specifies you want the version of this type that can be null. |
| `isReference` | When this option is specified, it returns a boolean as to if it is a reference type object (`true`) or not (`false`). |
| `self` | Uses the `self` keyword in this language (for Java this would be `this`) as the object from which to reference the input. |
| `object` | Allows you to directly specify the object name from which the input is referenced. |

<hr/>

<a name="filter_detail_lowercase"></a>
##### Filter: `lowercase`

Forces all characters of the input to be lowercase.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string to make all lowercase. |

<hr/>

<a name="filter_detail_map"></a>
##### Filter: `map`

This filter is probably the most complicated one but can be very powerful in helping to pattern match an expression at its input with one provided as a parameter. When the expressions match, it not only returns true but also maps operands from the input expression to the parameter expression.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTExpression` | An expression is a tree of operations, constants, methods and operands that evaluate to something at runtime. An example of an expression is like a constraint placed on an attribute. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `map:`*mapExpression* | Specifies the expression into which to map the input expression of this filter. |

<hr/>

<a name="filter_detail_name"></a>
##### Filter: `name`

This simply calls `getName()` on the input. It is more of a convenient way to get the name by using a filter.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTNamed` | Any class that has a `name` property or `getName()` method. |

<hr/>

<a name="filter_detail_nameas"></a>
##### Filter: `nameas`

Places underscore between words then forces all characters to be lowercase.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string to change into an underscore lowercase format. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `nameas:`*method* | Specifies the naming method: standard, underscore, underscoreLowercase, underscoreUppercase, lowercase, uppercase, capitalize, dashesLowercase, dashesUppercase, parentPrefix |

<hr/>

<a name="filter_detail_path"></a>
##### Filter: `path`

This will convert a string or namespace object into a string where by a '/' character is used as a delimiter instead of a '.'. This is useful when you need to convert a namespace into a filepath.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string that represents a period-delimited namespace (for instance: com.example.something). |
| `MTNamespace` | A namespace object that is obtained from an object in your model. |

<hr/>

<a name="filter_detail_plural"></a>
##### Filter: `plural`

This will attempt to pluralize the last word of the input string. If it can't determine the pluralization it may just return the same string.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string to pluralize. |

<hr/>

<a name="filter_detail_reverse"></a>
##### Filter: `reverse`

Given a collection of objects, this will return a collection that has the reverse order of the input.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `Collection<MTAttribute>` | Represents an attribute of an entity. |
| `Collection<MTDEAttribute>` | Represents an attribute in your model in the context of a domain. |
| `Collection<MTEntity>` | Represents an entity in your model. |
| `Collection<MTDEntity>` | Represents an entity in your model in the context of a domain. |
| `Collection<MTModule>` | Represents a grouping of entities. |
| `Collection<MTEnum>` | Represents an enum in your model. |
| `Collection<MTEnumItem>` | Represents an enum item. |
| `Collection<MTRelationship>` | Represents a relationship of an entity. |
| `Collection<MTDERelationship>` | Represents a relationship in your model in the context of a domain. |
| `Collection<FTTemplate>` | Represents an actual template containing code to execute. |

<hr/>

<a name="filter_detail_sort"></a>
##### Filter: `sort`

Given a collection of objects, this will return a collection that is sorted by name. This is useful when generating code that is consistent each time in terms of the order of objects in the output.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `Collection<MTDomain>` | Represents a domain. |
| `Collection<MTAttribute>` | Represents an attribute of an entity. |
| `Collection<MTDEAttribute>` | Represents an attribute in your model in the context of a domain. |
| `Collection<MTEntity>` | Represents an entity in your model. |
| `Collection<MTDEntity>` | Represents an entity in your model in the context of a domain. |
| `Collection<MTModule>` | Represents a grouping of entities. |
| `Collection<MTEnum>` | Represents an enum in your model. |
| `Collection<MTEnumItem>` | Represents an enum item. |
| `Collection<MTRelationship>` | Represents a relationship of an entity. |
| `Collection<MTDERelationship>` | Represents a relationship in your model in the context of a domain. |
| `Collection<MTTagDef>` | This class represents the definition of a tag. This is mostly to allow documentation of tags that are used in templates and placed on entities and attributes (including domain entities and domain attributes). |
| `Collection<FTTemplate>` | Represents an actual template containing code to execute. |

<hr/>

<a name="filter_detail_title"></a>
##### Filter: `title`

Given a string of words in camel case format, this will capitalize each word in the string except those words that are typically not capitalized in a title (such as 'of', 'the'. 'and', etc.).

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string representation of some type of identifier or name that us using camel case to combine words without spaces. |
| `MTNamed` | Any class that has a `name` property or `getName()` method. |

<hr/>

<a name="filter_detail_trim"></a>
##### Filter: `trim`

Removes white space from both ends of the input string.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to trim. |

<hr/>

<a name="filter_detail_type"></a>
##### Filter: `type`

Filters attribute lists optionally by its type (only array/single type supported currently).

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `Collection<MTAttribute>` | Represents an attribute of an entity. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `single` | This will filter the attribute list such that it only contains non-array attributes. |

<hr/>

<a name="filter_detail_uncapitalize"></a>
##### Filter: `uncapitalize`

Uncapitalizes the input string - that is, it forces the first character to be lowercase.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to uncapitalize. |

<hr/>

<a name="filter_detail_uppercase"></a>
##### Filter: `uppercase`

Forces all characters of the input to be uppercase.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to make all uppercase. |

<hr/>

<a name="filter_detail_view"></a>
##### Filter: `view`

Given a domain entity and the name of a view, this will return the view object.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `MTDEntity` | Represents an entity in your model in the context of a domain. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `view:`*viewName* | Specifies a specific view name to get from the entity. |

<hr/>

<a name="filter_detail_words"></a>
##### Filter: `words`

Given a string of words in camel case format, this will simply break up the words using a space character as a delimiter and does not change upper or lower case.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | This string that you want to break out into words. |

<hr/>

<a name="filter_detail_wrap"></a>
##### Filter: `wrap`

Given a sentence or paragraph string and an optional line width, this will perform a word wrap of the string to the output. You can optionally provide a line prefix (such as a line comment designator). The column position of the first line is used as the starting column position of each wrapped line of text.

Valid inputs for this filter are:

| Class of Valid Input | Description |
|---|---|
| `String` | The string you want to wrap. |

This filter has the following parameters:

| Usage with Parameter | Description |
|---|---|
| `wrap:`*prefix* | The line prefix to include for each line. The default is '//'. |


Options are specified in one of two ways: *option* (by itself) or *option*`:`*value* (with a value). When specifying just the *option*, it is equivalent to *option*`:true`.

The following options are available:

| Option | Description |
|---|---|
| `lineWidth` | Specifies the number of characters per line before wrapping. Default is 80. |


## Model Classes

Your application model contains all entities, attributes, relationships, domains, etc. that you have defined. Each type of element in your model has its own class and are placed into a tree structure after parsing your source files.

These classes are explained in detail in their own document: [Entity Model Classes](EMC.md). 